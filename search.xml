<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JPA注解@Enumerated映射枚举字段]]></title>
    <url>%2F2017%2F10%2F12%2FJPA%E6%B3%A8%E8%A7%A3-Enumerated%E6%98%A0%E5%B0%84%E6%9E%9A%E4%B8%BE%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[在javax.persistence包中有这么两个注解@Enumerated,@EnumType 123456789101112131415 */@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface Enumerated &#123; /** (Optional) The type used in mapping an enum type. */ EnumType value() default ORDINAL;&#125;public enum EnumType &#123; /** 持久枚举类型字段为整数，元素一般从0开始索引. */ ORDINAL, /** 持久枚举类型为字符串. */ STRING&#125; 当我需要持久化一个枚举类字段的时候，就可以用@Enumerated来标注枚举类型。来举个栗子： 数据库中有一张employee表 对应的Employee实体 123456789101112131415161718192021222324@Entity@Table(name = "employee", schema = "public")@Data@Builder@AllArgsConstructor@NoArgsConstructorpublic class Employee &#123; @Id @GeneratedValue @Column(name = "id") private Long id; @Column(name = "name") private String name; @Column(name = "sex") @Enumerated(EnumType.ORDINAL)//性别字段持久化为0，1 private Sex sex; @Column(name = "type") @Enumerated(EnumType.STRING)//枚举字符串 private Type type;&#125; Sex枚举类： 1234567891011public enum Sex &#123; MAIL("男"), FMAIL("女"); private String value; private Sex(String value) &#123; this.value = value; &#125;&#125; Type枚举类： 12345678910111213public enum Type &#123; PROGRAMMER("开发"), PM("项目经理"), TESTERS("测试"), UI("妹子"), ; private String type; private Type(String type) &#123; &#125;&#125; 那现在我们来看一下插入几条数据看下是什么效果。 123456789EmployeeRepostory employeeRepostory = context.getBean(EmployeeRepostory.class);Employee fireYao = Employee.builder().name("fireYao").sex(Sex.MAIL).type(Type.PROGRAMMER).build();Employee gakki = Employee.builder().name("gakki").sex(Sex.FMAIL).type(Type.UI).build();Employee whoever = Employee.builder().name("whoever").sex(Sex.FMAIL).type(Type.PM).build();employeeRepostory.save(Arrays.asList(fireYao,gakki,whoever)); 插入数据后，数据库中： 可以看到，sex字段被持久化为0,1这样的int字段，因为在sex字段上标注了@Enumerated(EnumType.ORDINAL)，那这样持久化到数据库时，就会根据枚举类中的字段，依次从0开始标记，Sex中MAIL(&quot;男&quot;)就为0,FMAIL(&quot;女&quot;)就为1,根据枚举类的字段个数依次递增。 在type字段上标注了@Enumerated(EnumType.STRING),就直接根据枚举类的字段字符串来自动持久化到数据库。 如果枚举字段上不加注解，那么枚举字段就会被默认映射为 int 类型存储。 那现在我们来看查询一下的结果。 1List&lt;Employee&gt; all = employeeRepostory.findAll(); 可以看到，查询出来的结果中sex字段又自动还原成了Sex枚举字段。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>jpa</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Data-JPA 动态查询黑科技]]></title>
    <url>%2F2017%2F10%2F10%2FSpring-Data-JPA-%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%E9%BB%91%E7%A7%91%E6%8A%80%2F</url>
    <content type="text"><![CDATA[在开发中,用到动态查询的地方,所有的查询条件包括分页参数,都会被封装成一个查询类XxxQuery 比如说上一篇中的Item 那么ItemQuery就像这样 1234567891011@Datapublic class ItemQuery &#123; private Integer itemId;//id精确查询 = private String itemName;//name模糊查询 like //价格查询 private Integer itemPrice;// 价格小于'条件' &lt;&#125; 那现在问题来了,如何去标识这些字段该用怎样的查询条件连接呢,还要考虑到每个查询类都可以通用. 可以用字段注解,来标识字段的查询连接条件 12345678910111213141516171819//用枚举类表示查询连接条件public enum MatchType &#123; equal, // filed = value //下面四个用于Number类型的比较 gt, // filed &gt; value ge, // field &gt;= value lt, // field &lt; value le, // field &lt;= value notEqual, // field != value like, // field like value notLike, // field not like value // 下面四个用于可比较类型(Comparable)的比较 greaterThan, // field &gt; value greaterThanOrEqualTo, // field &gt;= value lessThan, // field &lt; value lessThanOrEqualTo, // field &lt;= value ;&#125; 12345678910111213141516@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface QueryWord &#123; // 数据库中字段名,默认为空字符串,则Query类中的字段要与数据库中字段一致 String column() default ""; // equal, like, gt, lt... MatchType func() default MatchType.equal; // object是否可以为null boolean nullable() default false; // 字符串是否可为空 boolean emptiable() default false;&#125; 好了,现在我们可以改造一下ItemQuery了 12345678910111213@Datapublic class ItemQuery &#123; @QueryWord(column = "item_id", func = MatchType.equal) private Integer itemId; @QueryWord(func = MatchType.like) private String itemName; @QueryWord(func = MatchType.le) private Integer itemPrice;&#125; 现在,我们还需要去构造出查询时的动态条件,那就创建一个所有查询类的基类BaseQuery,我们把分页的条件字段放在基类里. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154/** * 所有查询类的基类 */@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic abstract class BaseQuery&lt;T&gt; &#123; // start from 0 protected int pageIndex = 0; protected int pageSize = 10; /** * 将查询转换成Specification * @return */ public abstract Specification&lt;T&gt; toSpec(); //JPA分页查询类 public Pageable toPageable() &#123; return new PageRequest(pageIndex, pageSize); &#125; //JPA分页查询类,带排序条件 public Pageable toPageable(Sort sort) &#123; return new PageRequest(pageIndex, pageSize, sort); &#125; //动态查询and连接 protected Specification&lt;T&gt; toSpecWithAnd() &#123; return this.toSpecWithLogicType("and"); &#125; //动态查询or连接 protected Specification&lt;T&gt; toSpecWithOr() &#123; return this.toSpecWithLogicType("or"); &#125; //logicType or/and private Specification&lt;T&gt; toSpecWithLogicType(String logicType) &#123; BaseQuery outerThis = this; return (root, criteriaQuery, cb) -&gt; &#123; Class clazz = outerThis.getClass(); //获取查询类Query的所有字段,包括父类字段 List&lt;Field&gt; fields = getAllFieldsWithRoot(clazz); List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(fields.size()); for (Field field : fields) &#123; //获取字段上的@QueryWord注解 QueryWord qw = field.getAnnotation(QueryWord.class); if (qw == null) continue; // 获取字段名 String column = qw.column(); //如果主注解上colume为默认值"",则以field为准 if (column.equals("")) column = field.getName(); field.setAccessible(true); try &#123; // nullable Object value = field.get(outerThis); //如果值为null,注解未标注nullable,跳过 if (value == null &amp;&amp; !qw.nullable()) continue; // can be empty if (value != null &amp;&amp; String.class.isAssignableFrom(value.getClass())) &#123; String s = (String) value; //如果值为"",且注解未标注emptyable,跳过 if (s.equals("") &amp;&amp; !qw.emptiable()) continue; &#125; //通过注解上func属性,构建路径表达式 Path path = root.get(column); switch (qw.func()) &#123; case equal: predicates.add(cb.equal(path, value)); break; case like: predicates.add(cb.like(path, "%" + value + "%")); break; case gt: predicates.add(cb.gt(path, (Number) value)); break; case lt: predicates.add(cb.lt(path, (Number) value)); break; case ge: predicates.add(cb.ge(path, (Number) value)); break; case le: predicates.add(cb.le(path, (Number) value)); break; case notEqual: predicates.add(cb.notEqual(path, value)); break; case notLike: predicates.add(cb.notLike(path, "%" + value + "%")); break; case greaterThan: predicates.add(cb.greaterThan(path, (Comparable) value)); break; case greaterThanOrEqualTo: predicates.add(cb.greaterThanOrEqualTo(path, (Comparable) value)); break; case lessThan: predicates.add(cb.lessThan(path, (Comparable) value)); break; case lessThanOrEqualTo: predicates.add(cb.lessThanOrEqualTo(path, (Comparable) value)); break; &#125; &#125; catch (Exception e) &#123; continue; &#125; &#125; Predicate p = null; if (logicType == null || logicType.equals("") || logicType.equals("and")) &#123; p = cb.and(predicates.toArray(new Predicate[predicates.size()]));//and连接 &#125; else if (logicType.equals("or")) &#123; p = cb.or(predicates.toArray(new Predicate[predicates.size()]));//or连接 &#125; return p; &#125;; &#125; //获取类clazz的所有Field，包括其父类的Field private List&lt;Field&gt; getAllFieldsWithRoot(Class&lt;?&gt; clazz) &#123; List&lt;Field&gt; fieldList = new ArrayList&lt;&gt;(); Field[] dFields = clazz.getDeclaredFields();//获取本类所有字段 if (null != dFields &amp;&amp; dFields.length &gt; 0) fieldList.addAll(Arrays.asList(dFields)); // 若父类是Object，则直接返回当前Field列表 Class&lt;?&gt; superClass = clazz.getSuperclass(); if (superClass == Object.class) return Arrays.asList(dFields); // 递归查询父类的field列表 List&lt;Field&gt; superFields = getAllFieldsWithRoot(superClass); if (null != superFields &amp;&amp; !superFields.isEmpty()) &#123; superFields.stream(). filter(field -&gt; !fieldList.contains(field)).//不重复字段 forEach(field -&gt; fieldList.add(field)); &#125; return fieldList; &#125;&#125; 在BaseQuery里,就通过toSpecWithAnd() toSpecWithOr()方法动态构建出了查询条件. 那现在ItemQuery就要继承BaseQuery,并实现toSpec()抽象方法 1234567891011121314151617@Datapublic class ItemQuery extends BaseQuery&lt;Item&gt; &#123; @QueryWord(column = "item_id", func = MatchType.equal) private Integer itemId; @QueryWord(func = MatchType.like) private String itemName; @QueryWord(func = MatchType.le) private Integer itemPrice; @Override public Specification&lt;Item&gt; toSpec() &#123; return super.toSpecWithAnd();//所有条件用and连接 &#125;&#125; 当然肯定还有其他不能在BaseQuery中构建的查询条件,那就在子类的toSpec()实现中添加, 比如下面的例子,ItemQuery条件改成这样 123456789@QueryWord(column = "item_id", func = MatchType.equal)private Integer itemId;@QueryWord(func = MatchType.like)private String itemName;//价格范围查询private Integer itemPriceMin;private Integer itemPriceMax; 那其他条件就可以在toSpec()添加,这样就可以很灵活的构建查询条件了 123456789101112131415161718192021@Overridepublic Specification&lt;Item&gt; toSpec() &#123; Specification&lt;Item&gt; spec = super.toSpecWithAnd(); return ((root, criteriaQuery, criteriaBuilder) -&gt; &#123; List&lt;Predicate&gt; predicatesList = new ArrayList&lt;&gt;(); predicatesList.add(spec.toPredicate(root, criteriaQuery, criteriaBuilder)); if (itemPriceMin != null) &#123; predicatesList.add( criteriaBuilder.and( criteriaBuilder.ge( root.get(Item_.itemPrice), itemPriceMin))); &#125; if (itemPriceMax != null) &#123; predicatesList.add( criteriaBuilder.and( criteriaBuilder.le( root.get(Item_.itemPrice), itemPriceMax))); &#125; return criteriaBuilder.and(predicatesList.toArray(new Predicate[predicatesList.size()])); &#125;);&#125; 调用: 123456789@Testpublic void test1() throws Exception &#123; ItemQuery itemQuery = new ItemQuery(); itemQuery.setItemName("车"); itemQuery.setItemPriceMax(50); itemQuery.setItemPriceMax(200); Pageable pageable = itemQuery.toPageable(new Sort(Sort.Direction.ASC, "itemId")); Page&lt;Item&gt; all = itemRepository.findAll(itemQuery.toSpec(), pageable);&#125; 现在这个BaseQuery和QuertWord就可以在各个动态查询处使用了,只需在查询字段上标注@QueryWord注解, 然后实现BaseQuery中的抽象方法toSpec(),通过JpaSpecificationExecutor接口中的这几个方法,就可以实现动态查询了,是不是很方便. 1234567public interface JpaSpecificationExecutor&lt;T&gt; &#123; T findOne(Specification&lt;T&gt; var1); List&lt;T&gt; findAll(Specification&lt;T&gt; var1); Page&lt;T&gt; findAll(Specification&lt;T&gt; var1, Pageable var2); List&lt;T&gt; findAll(Specification&lt;T&gt; var1, Sort var2); long count(Specification&lt;T&gt; var1);&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Data-JPA criteria 查询]]></title>
    <url>%2F2017%2F10%2F10%2FSpring-Data-JPA-criteria-%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Spring Data JPA虽然大大的简化了持久层的开发,但是在实际开发中,很多地方都需要高级动态查询 Criteria API Criteria 查询是以元模型的概念为基础的，元模型是为具体持久化单元的受管实体定义的，这些实体可以是实体类，嵌入类或者映射的父类。 CriteriaQuery接口：代表一个specific的顶层查询对象，它包含着查询的各个部分，比如：select 、from、where、group by、order by等注意：CriteriaQuery对象只对实体类型或嵌入式类型的Criteria查询起作用 Root接口：代表Criteria查询的根对象，Criteria查询的查询根定义了实体类型，能为将来导航获得想要的结果，它与SQL查询中的FROM子句类似 ​ 1：Root实例是类型化的，且定义了查询的FROM子句中能够出现的类型。 ​ 2：查询根实例能通过传入一个实体类型给 AbstractQuery.from方法获得。 ​ 3：Criteria查询，可以有多个查询根。 ​ 4：AbstractQuery是CriteriaQuery 接口的父类，它提供得到查询根的方法。CriteriaBuilder接口：用来构建CritiaQuery的构建器对象Predicate：一个简单或复杂的谓词类型，其实就相当于条件或者是条件组合 如果编译器能够对查询执行语法正确性检查，那么对于 Java 对象而言该查询就是类型安全的。Java™Persistence API (JPA) 的 2.0 版本引入了 Criteria API，这个 API 首次将类型安全查询引入到 Java 应用程序中，并为在运行时动态地构造查询提供一种机制。 JPA元模型 在JPA中,标准查询是以元模型的概念为基础的.元模型是为具体持久化单元的受管实体定义的.这些实体可以是实体类,嵌入类或者映射的父类.提供受管实体元信息的类就是元模型类. 使用元模型类最大的优势是凭借其实例化可以在编译时访问实体的持久属性.该特性使得criteria 查询更加类型安全. 如下,Item实体类对应的元模型Item_ 12345678@Generated(value = "org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor")@StaticMetamodel(Item.class)public abstract class Item_ &#123; public static volatile SingularAttribute&lt;Item, Integer&gt; itemId; public static volatile SingularAttribute&lt;Item, String&gt; itemName; public static volatile SingularAttribute&lt;Item, Integer&gt; itemStock; public static volatile SingularAttribute&lt;Item, Integer&gt; itemPrice;&#125; 这样的元模型不用手动创建,在Maven中添加插件,编译之后@Entity注解的类就会自动生成对应的元模型 12345678910111213&lt;!--hibernate JPA 自动生成元模型--&gt;&lt;!-- 相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;5.2.10.Final&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.1.0.Final&lt;/version&gt; &lt;/dependency&gt; 12345678910&lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;compilerArguments&gt; &lt;processor&gt;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&lt;/processor&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; 使用criteria 查询简单Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Servicepublic class ItemServiceImpl implements ItemService &#123; @Resource private EntityManager entityManager; @Override public List&lt;Item&gt; findByConditions(String name, Integer price, Integer stock) &#123; //创建CriteriaBuilder安全查询工厂 //CriteriaBuilder是一个工厂对象,安全查询的开始.用于构建JPA安全查询. CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder(); //创建CriteriaQuery安全查询主语句 //CriteriaQuery对象必须在实体类型或嵌入式类型上的Criteria 查询上起作用。 CriteriaQuery&lt;Item&gt; query = criteriaBuilder.createQuery(Item.class); //Root 定义查询的From子句中能出现的类型 Root&lt;Item&gt; itemRoot = query.from(Item.class); //Predicate 过滤条件 构建where字句可能的各种条件 //这里用List存放多种查询条件,实现动态查询 List&lt;Predicate&gt; predicatesList = new ArrayList&lt;&gt;(); //name模糊查询 ,like语句 if (name != null) &#123; predicatesList.add( criteriaBuilder.and( criteriaBuilder.like( itemRoot.get(Item_.itemName), "%" + name + "%"))); &#125; // itemPrice 小于等于 &lt;= 语句 if (price != null) &#123; predicatesList.add( criteriaBuilder.and( criteriaBuilder.le( itemRoot.get(Item_.itemPrice), price))); &#125; //itemStock 大于等于 &gt;= 语句 if (stock != null) &#123; predicatesList.add( criteriaBuilder.and( criteriaBuilder.ge( itemRoot.get(Item_.itemStock), stock))); &#125; //where()拼接查询条件 query.where(predicatesList.toArray(new Predicate[predicatesList.size()])); TypedQuery&lt;Item&gt; typedQuery = entityManager.createQuery(query); List&lt;Item&gt; resultList = typedQuery.getResultList(); return resultList; &#125;&#125; criteriaBuilder中各方法对应的语句 equle : filed = value gt / greaterThan : filed &gt; value lt / lessThan : filed &lt; value ge / greaterThanOrEqualTo : filed &gt;= value le / lessThanOrEqualTo: filed &lt;= value notEqule : filed != value like : filed like value notLike : filed not like value 如果每个动态查询的地方都这么写,那就感觉太麻烦了. 那实际上,在使用Spring Data JPA的时候，只要我们的Repo层接口继承JpaSpecificationExecutor接口就可以使用Specification进行动态查询了，我们先看下JpaSpecificationExecutor接口： 1234567891011public interface JpaSpecificationExecutor&lt;T&gt; &#123; T findOne(Specification&lt;T&gt; var1); List&lt;T&gt; findAll(Specification&lt;T&gt; var1); Page&lt;T&gt; findAll(Specification&lt;T&gt; var1, Pageable var2); List&lt;T&gt; findAll(Specification&lt;T&gt; var1, Sort var2); long count(Specification&lt;T&gt; var1);&#125; 在这里有个很重要的接口Specification 123public interface Specification&lt;T&gt; &#123; Predicate toPredicate(Root&lt;T&gt; var1, CriteriaQuery&lt;?&gt; var2, CriteriaBuilder var3);&#125; 这个接口只有一个方法,返回动态查询的数据结构,用于构造各种动态查询的SQL Specification接口示例 1234567891011121314151617181920212223242526272829public Page&lt;Item&gt; findByConditions(String name, Integer price, Integer stock, Pageable page) &#123; Page&lt;Item&gt; page = itemRepository.findAll((root, criteriaQuery, criteriaBuilder) -&gt; &#123; List&lt;Predicate&gt; predicatesList = new ArrayList&lt;&gt;(); //name模糊查询 ,like语句 if (name != null) &#123; predicatesList.add( criteriaBuilder.and( criteriaBuilder.like( root.get(Item_.itemName), "%" + name + "%"))); &#125; // itemPrice 小于等于 &lt;= 语句 if (price != null) &#123; predicatesList.add( criteriaBuilder.and( criteriaBuilder.le( root.get(Item_.itemPrice), price))); &#125; //itemStock 大于等于 &gt;= 语句 if (stock != null) &#123; predicatesList.add( criteriaBuilder.and( criteriaBuilder.ge( root.get(Item_.itemStock), stock))); &#125; return criteriaBuilder.and( predicatesList.toArray(new Predicate[predicatesList.size()])); &#125;, page); return page;&#125; 在这里因为findAll(Specification&lt;T&gt; var1, Pageable var2)方法中参数 Specification&lt;T&gt; 是一个匿名内部类 那这里就可以直接用lambda表达式直接简化代码. 这样写,就比用CriteriaBuilder安全查询工厂简单多了. 调用: 1Page&lt;Item&gt; itemPageList = findByConditions("车", 300, null, new PageRequest(1, 10)); 利用JPA的Specification&lt;T&gt;接口和元模型就实现动态查询了. 那其实这样每一个需要动态查询的地方都需要写一个这样类似的findByConditions方法,感觉也很麻烦了.当然是越简化越好. 下一篇将会讲一个JPASpecification更方便的使用.]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 的使用]]></title>
    <url>%2F2017%2F10%2F09%2Fspring-data-jpa-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[上一篇Spring JavaConfig中配置数据源使用了JPA,这里就介绍一下Spring data jpa的常用方法. spring data jpa介绍什么是JPA JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具来管理Java应用中的关系数据。 Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！ spring data jpa让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现 简单查询 基本查询也分为两种，一种是spring data默认已经实现，一种是根据查询的方法来自动解析成SQL。 spring data jpa 默认预先生成了一些基本的CURD的方法，例如：增、删、改等等 123public interface ItemRepository extends JpaRepository&lt;Item, Integer&gt;, JpaSpecificationExecutor&lt;Item&gt; &#123;//空的，可以什么都不用写&#125; 123456789@Testpublic void test1() throws Exception &#123; Item item = new Item(); itemRepository.save(item); List&lt;Item&gt; itemList = itemRepository.findAll(); Item one = itemRepository.findOne(1); itemRepository.delete(item); long count = itemRepository.count();&#125; 自定义简单查询 1234567Item findByItemName(String itemName);List&lt;Item&gt; findByItemNameLike(String itemName);Long deleteByItemId(Integer id);List&lt;Item&gt; findByItemNameLikeOrderByItemNameDesc(String itemName); 具体的关键字，使用方法和生产成SQL如下表所示 Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstnameIs,findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age ⇐ ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection age) … where x.age not in ?1 TRUE findByActiveTrue() … where x.active = true FALSE findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 分页查询 1Page&lt;Item&gt; findALL(Pageable pageable); 12345678@Testpublic void test1() throws Exception &#123; int page=1,size=10; Sort sort = new Sort(Sort.Direction.DESC, "id");//根据id降序排序 Pageable pageable = new PageRequest(page, size, sort); Page&lt;Item&gt; pageResult = itemRepository.findALL(pageable); List&lt;Item&gt; itemList = pageResult.getContent();&#125; 自定义SQL查询 在SQL的查询方法上面使用@Query注解，如涉及到删除和修改在需要加上@Modifying.也可以根据需要添加 @Transactional 对事物的支持 1234567891011121314151617//自定分页查询 一条查询数据,一条查询数据量@Query(value = "select i from Item i", countQuery = "select count(i.itemId) from Item i")Page&lt;Item&gt; findall(Pageable pageable);//nativeQuery = true 本地查询 就是使用原生SQL查询@Query(value = "select * from item where item_id = ?1", nativeQuery = true)Item findAllItemById(int id);@Transactional@Modifying@Query("delete from Item i where i.itemId = :itemId")void deleteInBulkByItemId(@Param(value = "itemId") Integer itemId);//#&#123;#entityName&#125;就是指定的@Entity,这里就是Item @Query("select i from #&#123;#entityName&#125; i where i.itemId = ?1") Item findById(Integer id); 命名查询 在实体类上使用@NameQueries注解 在自己实现的DAO的Repository接口里面定义一个同名的方法 然后就可以使用了，Spring会先找是否有同名的NamedQuery，如果有，那么就不会按照接口定义的方法来解析。 123456789101112131415161718//命名查询@NamedQueries(&#123; @NamedQuery(name = "Item.findItemByitemPrice", query = "select i from Item i where i.itemPrice between ?1 and ?2"), @NamedQuery(name = "Item.findItemByitemStock", query = "select i from Item i where i.itemStock between ?1 and ?2"),&#125;)@Entity@Datapublic class Item implements Serializable &#123; @Id @GeneratedValue @Column(name = "item_id") private int itemId; private String itemName; private Integer itemPrice; private Integer itemStock; &#125; 12345678910/** * 这里是在domain实体类里@NamedQuery写对应的HQL * @NamedQuery(name = "Item.findItemByitemPrice", baseQuery = "select i from Item i where i.itemPrice between ?1 and ?2"), * @param price1 * @param price2 * @return */List&lt;Item&gt; findItemByitemPrice(Integer price1, Integer price2);List&lt;Item&gt; findItemByitemStock(Integer stock1, Integer stock2); 那么spring data jpa是怎么通过这些规范来进行组装成查询语句呢? Spring Data JPA框架在进行方法名解析时，会先把方法名多余的前缀截取掉，比如 find、findBy、read、readBy、get、getBy，然后对剩下部分进行解析。假如创建如下的查询：findByUserDepUuid()，框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析 先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步； 从右往左截取第一个大写字母开头的字符串此处为Uuid），然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设user为查询实体的一个属性； 接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 Doc.user.depUuid 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 Doc.user.dep.uuid 的值进行查询。 可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 findByUser_DepUuid() 或者 findByUserDep_uuid()]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丢掉xml使用JavaConfig配置Spring]]></title>
    <url>%2F2017%2F10%2F09%2F%E4%B8%A2%E6%8E%89xml%E4%BD%BF%E7%94%A8JavaConfig%E9%85%8D%E7%BD%AESpring%2F</url>
    <content type="text"><![CDATA[Spring JavaConfig最近撸了一遍Spring action 4,发现里面讲的都不再使用xml文件来配置spring,全都采用Java代码来配置. 用Java代码配置的话,感觉要比xml更便于维护,而且用代码肯定比xml更爽嘛 下面来一步步用JavaConfig搭一个Spring工程 那在用xml配置的时候,项目都是从加载web.xml文件再扫描到各种spring-*.xml文件 那不用xml文件,项目从哪里启动呢? 那就要靠这个类了,AbstractAnnotationConfigDispatcherServletInitializer,这个就相当于web.xml啦,在这里面可以配置上下文,DispatcherServlet,过滤器等等bean; 首先咱先创建一个类SpittrWebAppInitialzer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.fireyao;import org.springframework.web.filter.CharacterEncodingFilter;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import javax.servlet.Filter;public class SpittrWebAppInitialzer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 配置root上下文,如Jpa数据源等等的配置 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;RootConfig.class&#125;; &#125; /** * 配置dispatcher servlet * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 将DispatcherServlet映射到 "/" * 指定开始被servlet处理的url,配置从/开始 * @return */ @Override protected String[] getServletMappings() &#123; return new String[]&#123;"/"&#125;; &#125; /** * 这里注册的所有过滤器,都会映射到DispatcherServlet * 就是说这里的过滤器过滤规则是 /* * 所有的请求都会先到这里注册的过滤器中 * * @return */ @Override protected Filter[] getServletFilters() &#123; return new Filter[]&#123; new CharacterEncodingFilter("UTF-8", true) &#125;; &#125;&#125; 在SpittrWebAppInitialzer类里面加载了RootConfig和WebConfig两个配置类, 再创建这两个类以及相关的配置(以下省略package和import) RootConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 相当于applicationContext.xml */@Configuration@EnableTransactionManagement@EnableJpaRepositories(basePackages = &#123;"com.fireyao.repository"&#125;, entityManagerFactoryRef = "entityManagerFactory", transactionManagerRef = "transactionManager")@PropertySource(value = &#123;"classpath:db.properties", "classpath:hibernate.properties", "classpath:app.properties"&#125;)@ComponentScan(basePackages = "com.fireyao", excludeFilters = &#123; @ComponentScan.Filter( type = FilterType.ANNOTATION, value = EnableWebMvc.class )&#125;)@EnableAspectJAutoProxy(proxyTargetClass = true)/** * proxyTargetClass = true ==&gt; 使用cglib代理 * proxyTargetClass = false(默认) ==&gt; 使用JDK代理 */public class RootConfig &#123; @Value(value = "$&#123;db.driver:org.postgresql.Driver&#125;") private String DRIVERCLASSNAME; @Value("$&#123;db.username&#125;") private String USERNAME; @Value("$&#123;db.password&#125;") private String PASSWORD; @Value("$&#123;db.jdbcURL&#125;") private String URL; @Value("$&#123;hibernate.hbm2dll.create_namespaces&#125;") private String CREATE_NAMESPACES; @Value("$&#123;hibernate.hbm2ddl.auto&#125;") private String HBM2DDL_AUTO; @Value("$&#123;hibernate.show_sql&#125;") private String SHOW_SQL; @Value("$&#123;hibernate.format_sql&#125;") private String FORMAT_SQL; @Value("$&#123;hibernate.generate_statistics&#125;") private String GENERATE_STATISTICS; /** * 配置数据源 */ @Bean(name = "dataSource") public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(DRIVERCLASSNAME); dataSource.setUrl(URL); dataSource.setUsername(USERNAME); dataSource.setPassword(PASSWORD); /* 配置初始化大小、最小、最大*/ dataSource.setInitialSize(5); dataSource.setMinIdle(5); dataSource.setMaxActive(20); /* 配置获取连接等待超时的时间*/ dataSource.setMaxWait(30000); /*配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒*/ dataSource.setTimeBetweenEvictionRunsMillis(60000); /*配置一个连接在池中最小生存的时间，单位是毫秒*/ dataSource.setMinEvictableIdleTimeMillis(300000); /*申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效*/ dataSource.setTestWhileIdle(true); dataSource.setValidationQuery("select 1"); return dataSource; &#125; @Bean public HibernateJpaVendorAdapter hibernateJpaVendorAdapter() &#123; return new HibernateJpaVendorAdapter(); &#125; @Bean(name = "entityManagerFactory") public LocalContainerEntityManagerFactoryBean entityManagerFactory(DruidDataSource dataSource,HibernateJpaVendorAdapter hibernateJpaVendorAdapter) &#123; LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean(); entityManagerFactory.setDataSource(dataSource); entityManagerFactory.setJpaVendorAdapter(hibernateJpaVendorAdapter); entityManagerFactory.setPackagesToScan("com.fireyao.domain"); /*指定JPA属性；如Hibernate中指定是否显示SQL的是否显示、方言等*/ Map&lt;String, Object&gt; jpaProp = new HashMap(); jpaProp.put("hibernate.dialect", new PostgisDialect()); jpaProp.put("hibernate.hbm2ddl.auto", HBM2DDL_AUTO); jpaProp.put("hibernate.show_sql", SHOW_SQL); jpaProp.put("hibernate.generate_statistics", GENERATE_STATISTICS); jpaProp.put("hibernate.format_sql", FORMAT_SQL); jpaProp.put("hibernate.hbm2dll.create_namespaces", CREATE_NAMESPACES); entityManagerFactory.setJpaPropertyMap(jpaProp); return entityManagerFactory; &#125; /** * 事务管理器 * * @param entityManagerFactory * @return */ @Bean(name = "transactionManager") public JpaTransactionManager transactionManager(LocalContainerEntityManagerFactoryBean entityManagerFactory) &#123; return new JpaTransactionManager(entityManagerFactory.getObject()); &#125;&#125; WebConfig 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 相当于springmvc-servlet.xml */@Configuration@EnableWebMvc//启用spring mvc@ComponentScan(basePackages = "com.fireyao.controller") //启用组件扫描public class WebConfig extends WebMvcConfigurerAdapter &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat); //处理中文乱码问题 List&lt;MediaType&gt; fastMediaTypes = new ArrayList&lt;&gt;(); fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); fastConverter.setSupportedMediaTypes(fastMediaTypes); fastConverter.setFastJsonConfig(fastJsonConfig); converters.add(fastConverter); &#125; /** * Thymeleaf视图解析器 * * @param springTemplateEngine * @return */ @Bean public ThymeleafViewResolver viewResolver(SpringTemplateEngine springTemplateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setTemplateEngine(springTemplateEngine); viewResolver.setCharacterEncoding("utf-8"); return viewResolver; &#125; /** * 模版引擎 * * @param iTemplateResolver * @return */ @Bean public SpringTemplateEngine templateEngine(ITemplateResolver iTemplateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(iTemplateResolver); return templateEngine; &#125; /** * Thymeleaf3.0之后 * Thymeleaf模版解析器 * * @return */ @Bean public ITemplateResolver iTemplateResolver() &#123; SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver(); templateResolver.setTemplateMode("HTML5"); templateResolver.setPrefix("/WEB-INF/templates/"); templateResolver.setSuffix(".html"); templateResolver.setTemplateMode("HTML"); templateResolver.setCharacterEncoding("utf-8"); templateResolver.setCacheable(false); return templateResolver; &#125; /** * Thymeleaf3.0之前 * Thymeleaf模版解析器 * @return */ /* @Bean public TemplateResolver templateResolver() &#123; TemplateResolver resolver = new ServletContextTemplateResolver(); resolver.setPrefix("/WEB-INF/VIEWS/"); resolver.setSuffix(".html"); resolver.setTemplateMode("HTML5"); resolver.setCacheable(false); return resolver; &#125;*/ /** * 配置静态资源的处理 * 要求DispatcherServlet将对静态资源的请求转发到Servlet容器中默认的Servlet上 * 而不是使用DispatcherServlet本身来处理此类请求。 * * @param configurer */ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; /** * 配置视图解析器 * ==&gt; JSP视图 * * @return */ /*@Bean public ViewResolver viewResolver() &#123; InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125;*/&#125; @Configuration 标注为配置类 @EnableTransactionManagement注解开启注解式事务的支持。 @EnableJpaRepositories注解开启对Spring Data JPA Repostory的支持 @PropertySource 扫面db.properties等配置文件,可以用@Value注解取到properties中的值 @ComponentScan 配置扫描类包 相当于&lt;context:component-scan base-package=&quot;com.fireyao&quot;/&gt; @EnableAspectJAutoProxy 表示开启AOP代理自动配置 @EnableAspectJAutoProxy中proxyTargetClass属性​ proxyTargetClass = true ==&gt; 使用cglib代理​ proxyTargetClass = false(默认) ==&gt; 使用JDK代理 那spring最基本的JavaConfig就这样了. 是不是看上去很舒服,果然还是要用Java代码才爽. maven依赖就不贴出来了. 附上源码地址 FireYao/springAction4]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口映射+nginx对外请求控制]]></title>
    <url>%2F2017%2F10%2F09%2F%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84-nginx%E5%AF%B9%E5%A4%96%E8%AF%B7%E6%B1%82%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[​ 前几天接到个任务,要和另一家公司对接,具体就是我这开一个接口给对面调用.因为一开始在内网测试,那问题来了,怎么才能让对面访问到呢? ​ 当然是找运维大兄弟…..操作也很简单,就是用路由做一个端口映射,用公网ip做一个端口映射到我本机地址.这样外网就能访问到我的tomcat了. 比如说公网ip是192.168.1.0,我的ip是192.168.1.1,tomcat端口是8080. 那就在路由上配一个端口9876直接映射到本地tomcat 192.168.1.1:8080.那现在外网就可以通过http://192.168.1.0:9876/访问到本地http://192.168.1.1:8080/了. 就这样,做好了接口,问题又来了,因为这个接口是在核心系统里,那这样就会把所有的接口都暴露了,肯定不行.. 怎么做呢,怎么才能拦截这些请求呢? 当然又去问了运维大兄弟,再查了些资料,得知用Nginx可以只允许访问指定的url,其他的都直接对外禁止访问. 那怎么做呢? 重新修改下映射规则,不直接映射到tomcat,先经过nginx,通过nginx再把请求发送到tomcat. 这里就重新映射一个端口8000,在nginx中监听这个端口,然后再配置访问规则,再代理到tomcat 在nginx.config中添加一段server 12345678910111213141516171819202122232425262728server &#123; #监听8080端口,这个8080是路由映射到本机的端口 listen 8000; server_name 0.0.0.0; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #阻止所有请求,这里将永远输出403错误 deny all; &#125; #允许访问 /test/processe接口 location ~ /test/processe &#123; # 代理本地项目url proxy_pass http://192.168.4.48:8080; &#125; #如果还有其他接口,就再添加一个location #location ~ /test/processe1 &#123; #proxy_pass http://192.168.4.48:8080; #&#125; #location ~ /test/processe2 &#123; #proxy_pass http://192.168.4.48:8080; #&#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 这里的流程就是,外网通过访问公网ip+给定的端口,在路由根据映射规则,再访问到我这台电脑,这个时候请求不是直接去访问本机的接口,而是进入了Nginx,在这里,会去检查请求的url是否与配置允许的地址相同,不同的话就会403 Forbidden错误啦,当uri是/test/processe时,就能访问实际代理的http://192.168.4.48:8080/test/processe接口了 那这样就可以让对面只能访问指定的接口.]]></content>
      <categories>
        <category>开发随记</category>
      </categories>
      <tags>
        <tag>开发随记</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-新特性-Stream]]></title>
    <url>%2F2017%2F08%2F20%2FJava8-%E6%96%B0%E7%89%B9%E6%80%A7-Stream%2F</url>
    <content type="text"><![CDATA[了解Stream​ Java8中有两个最为重要的改变，一个是Lambda表达式，另一个就是Stream API,针对常见的集合数据处理，Stream API 提供了一种高效且易于使用的数据处理方式。 什么是Stream基本概念​ 流(Stream)用于操作数据源所生成的元素序列。Java 8给Collection接口增加了两个默认方法，它们可以返回一个Stream default Stream stream() {​ return StreamSupport.stream(spliterator(), false);}//stream()返回的是一个顺序流 default Stream parallelStream() {​ return StreamSupport.stream(spliterator(), true);}//parallelStream()返回的是一个并发流 Stream 自己不会存储元素。 Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 基本示例首先这里有一个Employee类 1234567public class Employee &#123; private int id; private String name; private int age; private double salary; /*省略getter setter Constructor*/&#125; 12345678910//Employee列表List&lt;Employee&gt; emps = Arrays.asList( new Employee(102, "李四", 59, 6666.66), new Employee(101, "张三", 18, 9999.99), new Employee(103, "王五", 28, 3333.33), new Employee(104, "赵六", 20, 7777.77), new Employee(104, "赵六", 19, 7777.77), new Employee(104, "赵四", 40, 7777.77), new Employee(105, "田七", 38, 5555.55)); 返回薪资大于5000的员工列表,java8以前是这样做的 123456List&lt;Employee&gt; newEmps = new ArrayList&lt;&gt;();for(Employee emp : emps)&#123; if(emp.salary &gt; 5000.00)&#123; newEmps.add(emp); &#125;&#125; 使用Stream API ,代码可以这样 123List&lt;Employee&gt; newEmps = emps.stream() .filter(s -&gt; s.getSalary() &gt; 5000.00) .collect(Collectors.toList()); 先通过stream()得到一个Stream对象，然后调用Stream上的方法，filter()过滤得到薪资大于5000的,它的返回值依然是一个Stream,然后通过调用collect()方法并传递一个Collectors.toList()将结果集存放到一个List中. 使用Stream API处理集合类代码更加简洁易读. 下面介绍一下Stream中的两种操作 Stream的中间操作和终止操作中间操作: ​ 多个 中间操作可以连接起来形成一个 流水线，除非流水线上触发终止操作，否则 中间操作不会执行任何的 处理！而在 终止操作时一次性全部 处理，称为“惰性求值” 方法 描述 filter(Predicate p) 接收 Lambda ， 从流中排除某些元素。 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去 limit(long maxSize) 截断流，使其元素不超过给定数量。 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序 sorted() 产生一个新流，其中按自然顺序排序 终止操作: ​ 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。 方法 描述 forEach(Consumer c) 内部迭代 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 count() 返回流中元素总数 收集 : collect(Collector c)方法需要一个Collector 作为参数,Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。Java8中提供了一个Collectors工具类, 工具中提供了很多静态方法，可以方便地创建常见收集器例 具体方法与实例如下表 方法 返回类型 作用 toList List 把流中元素收集到List toSet Set 把流中元素收集到Set toCollection Collection 把流中元素收集到创建的集合 groupingBy Map]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 新特性 函数式接口]]></title>
    <url>%2F2017%2F08%2F06%2FJava8-%E6%96%B0%E7%89%B9%E6%80%A7-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[什么是函数式接口​ Java 8引入了函数式接口的概念 ​ 1). 只包含一个抽象方法的接口，称为函数式接口 ​ 2). 函数式接口可以被隐式转换为lambda表达式。 ​ 3). 在任意函数式接口上使用@FunctionalInterface注解，这样做可以检查它是否是一个函数式接口，同时javadoc 也会包含一条声明，说明这个接口是一个函数式接口。 预定义的函数式接口​ Java 8定义了大量的预定义函数式接口，用于常见类型的代码传递，这些函数定义在包java.util.function下， 其中有四大核心函数式接口。 函数式接口 参数类型 返回类型 用途 Consumer(消费型接口) T void 对类型为T的对象应用操作。void accept(T t) Supplier(供给型接口) 无 T 返回类型为T的对象。 T get(); Function(函数型接口) T R 对类型为T的对象应用操作并返回R类型的对象。R apply(T t); Predicate(断言型接口) T boolean 确定类型为T的对象是否满足约束。boolean test(T t); Consumer 消费型接口 123456789public static void consume(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money);&#125;public static void main(String[] args) &#123; consume(10000, (m) -&gt; &#123; System.out.println("今日全场8折"); System.out.println("顾客消费：" + (m * 0.8) + "元"); &#125;);&#125; Supplier 供给型接口 1234567891011121314151617//生成num个整数,并存入集合public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list;&#125;public static void main(String[] args) &#123; //10个100以内的随机数 List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int) (Math.random() * 100)); for (Integer num : numList) &#123; System.out.println(num); &#125;&#125; Function 函数型接口 123456789101112131415161718192021222324252627282930313233343536373839/* Function接口常用于数据的处理转换,比如给定一个员工列表,需要返回名称列表*/public class Employee &#123; private int id; private String name; private double salary; public Employee(String name)&#123; this.name = name; &#125; public Employee(String name,double salary) &#123; this.name = name; this.salary = salary; &#125; //省略getter setter&#125;public class TestEmp&#123; public static &lt;T, R&gt;List&lt;R&gt; map(List&lt;T&gt; list,Function&lt;T, R&gt; fun)&#123; List&lt;R&gt; returnList = new ArrayList&lt;&gt;(list.size()); for (T e : list) &#123; returnList.add(fun.apply(e)); &#125; return returnList &#125; public static void main(String[] args) &#123; List&lt;Employee&gt; employees = Arrays.asList(new Employee("老张"), new Employee("小李"), new Employee("老王"), new Employee("小刘"), new Employee("小胖")); List&lt;String&gt; nameList = map(employees, (employee -&gt; employee.getName())); System.out.println(nameList); /* console:[老张, 小李, 老王, 小刘, 小胖] */ &#125;&#125; Predicate 断言型接口 1234567891011121314151617181920212223242526public static &lt;E&gt; List&lt;E&gt; filter(List&lt;E&gt; list, Predicate&lt;E&gt; pred) &#123; List&lt;E&gt; retList = new ArrayList&lt;&gt;(); for (E e : list) &#123; if (pred.test(e)) &#123; retList.add(e); &#125; &#125; return retList;&#125;public static void main(String[] args) &#123; List&lt;Employee&gt; employees = Arrays.asList(new Employee("老张"), new Employee("小李", 3000.00), new Employee("老王", 5000.00), new Employee("小刘", 7000.00), new Employee("小胖", 10000.00)); //过滤薪资小于5000的员工 List&lt;Employee&gt; filter = filter(employees, employee -&gt; employee.getSalary() &gt; 5000.00); for (Employee employee : filter) &#123; System.out.println(employee.getName() + ":" + employee.getSalary()); &#125; /* console:小刘:7000.0 小胖:10000.0 */&#125; 方法引用​ 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！方法引用：使用操作符 ::将方法名和对象或类的名字分隔开来。如下三种主要使用情况 ： 对象 : : 实例方法 类 : : 静态方法 类 : : 实例方法 基本用法 例如： 1234//静态方法BinaryOperator&lt;Double&gt; binaryOperator = (x, y) -&gt; Math.pow(x, y);//等价于BinaryOperator&lt;Double&gt; binaryOperator = Math::pow; 12345678910//实例方法: 类::实例方法Function&lt;Employee, String&gt; f = (Employee e) -&gt; e.getName();//等价于Function&lt;Employee, String&gt; f = Employee::getName;//---------------------------------------------------------//对象::实例方法Employee e = new Employee("小李", 3000.00);Supplier&lt;String&gt; s = () -&gt; e.getName();//等价于↓Supplier&lt;String&gt; s = e::getName; 构造方法​ 与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！对于构造方法，方法引用的语法是&lt;类名&gt;::new，如Employee::new，如下语句： 123Function&lt;String,Employee&gt; f = (name)-&gt;new Employee(name);//等价于↓Function&lt;String, Employee&gt; f = Employee::new; 接口中的默认方法和静态方法​ Java8以前，接口里的方法要求全部是抽象方法，Java8以后允许在接口里定义默认方法和静态方法,默认方法使用 default 关键字修饰。 例如： 1234567891011public interface MyFunction&#123; void func(); //声明一个接口的默认方法 default void testDefalut()&#123; System.out.println("MyFunction 默认方法"); &#125; //声明一个接口的静态方法 static void testStatic()&#123; System.out.println("MyFunction 静态方法"); &#125;&#125; 12345678910111213141516171819//MyFunctionImpl实现接口MyFunctionpublic class MyFunctionImpl implements MyFunction &#123; @Override public void func() &#123; System.out.println("实现抽象方法"); &#125; public static void main(String[] args) &#123; MyFunction my = new MyFunctionImpl(); my.func(); my.testDefalut(); MyFunction.testStatic(); &#125; /* 实现抽象方法 MyFunction 默认方法 MyFunction 静态方法 */&#125; 默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。 接口冲突​ 如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突 1234567891011121314151617public interface AnotherFunction &#123; default void testDefalut() &#123; System.out.println("AnotherFunction 默认方法"); &#125;&#125;public class FunctionImpl implements MyFunction,AnotherFunction&#123; @Override public void func() &#123; System.out.println(" FunctionImpl 实现抽象方法"); &#125; @Override public void testDefalut() &#123; System.out.println(" FunctionImpl 覆盖接口中默认方法解决冲突"); &#125;&#125; ​ 如果不覆盖接口中相同的默认方法，那么new MyFunctionImpl().testDefalut();中调用的testDefalut方法到底是哪个接口的testDefalut()方法呢？所以必须在实现类中覆盖testDefalut()方法。 小结​ 本章中介绍了Java 8中的函数式接口，Java8四大核心函数式接口，方法的引用，接口的默认方法和静态方法。 下章将介绍Java8中强大的Stream API]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
        <tag>函数式接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 新特性 Lambda表达式]]></title>
    <url>%2F2017%2F08%2F05%2FJava8-%E6%96%B0%E7%89%B9%E6%80%A7-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是Lambda表达式 Lambda可以理解为是一个匿名函数，Lambda表达式可以说是一段可以传递的代码。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 在Java8以前，我们是通过接口来传递代码的(面向接口的编程)。 比如： 12345678Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println("run----"); &#125; &#125;;Thread th = new Thread(runnable); 这里Thread类需要的其实并不是Runnable对象，而是它的方法 1public abstract void run(); 但是没有办法直接传递方法，只能通过接口来传递。 Java8提供了一种新的紧凑的传递代码的语法–就是Lambda表达式。比如刚才的Thread可以用lambda表达式修改为： 1234Runnable runnable = (() -&gt; System.out.println("run----"));Thread th = new Thread(runnable);//还可以继续简化Thread t = new Thread(() -&gt; System.out.println("run----")); 是不是简洁多了？。 1.Lambda表达式语法Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为 -&gt; ， 该操作符被称为 Lambda 操作符或剪头操作符。它将 Lambda 分为两个部分： 左侧: 指定了 Lambda 表达式所需要的所有参数 右侧:指定了 Lambda 体，即 Lambda 表达式要执行的功能即需传递的方法的实现。 语法格式: 1). 无参,无返回值,Lambda体只需一条语句 1Runnable runnable = (() -&gt; System.out.println("run----")); 2). Lambda需要一个参数 123Consumer&lt;String&gt; consumer = ((str) -&gt; System.out.println(str));//只有一个参数时，参数小括号可以省略，如下Consumer&lt;String&gt; consumer = (str -&gt; System.out.println(str)); 3). Lambda 需要两个参数，并且有返回值 12345Comparator&lt;Integer&gt; comparator = ((num1, num2) -&gt; &#123; return num1 - num2;&#125;);//当表达式内只有一条语句时，return和大括号可以省略，如下Comparator&lt;Integer&gt; comparator = ((num1, num2) -&gt; num1 - num2); 4). 数据类型可以省略，因为可由编译器推断得出，称为“类型推断” 123BinaryOperator&lt;Long&gt; binaryOperator = ((Long num1, Long num2) -&gt; num1 + num2);//(Long l1, Long l2) 中参数类型可以省略，编译器可以自动推断，如下↓BinaryOperator&lt;Long&gt; binaryOperator = ((num1, num2) -&gt; num1 + num2); 可以看出，相比匿名内部类，传递代码变得更为直观，不再有实现接口的模板代码，不再声明方法，也名字也没有，而是直接给出了方法的实现代码 2.变量引用​ 与匿名内部类类似，Lambda表达式也可以访问定义在主体代码外部的变量，但对于局部变量，它也只能访问final类型的变量，与匿名内部类的区别是，它不要求变量声明为final，但变量事实上不能被重新赋值。比如： 12Integer num = 1;Function&lt;Integer, Integer&gt; function = (integer -&gt; num); 可以访问局部变量num，但num不能被重新赋值，如果这样写： 1234Integer num = 1;Function&lt;Integer, Integer&gt; function = (integer -&gt; num++);//编译器报错//Variable used in lambda expression should be final or effectively final 与匿名内部内比较从以上内容可以看出，Lambda表达式与匿名内部类很像，主要就是简化了语法，使得编写更加简单，但Lambda与匿名内部类不同的是，java会为每个匿名内部类生成一个一个类，而Lambda表达式不会。 Lambda表达式不是匿名内部类，那它的类型到底是什么呢？是函数式接口。 小结​ 本章介绍了Lambda表达式，Lambda语法以及在Lambda表达式中的变量引用。 下篇将介绍Java8新特性，函数式接口]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[进来你就是我的人了 一颗赛艇 苟利国家生死以 岂因福祸趋避之 我跟你讲不要搞大新闻123while(alive)&#123; your.minit = 59s;&#125; 你觉得你跑得快是不是 别往下看，没了1/(o_ _)ﾉ]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hello</tag>
        <tag>膜法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+github一步一步搭建个人博客]]></title>
    <url>%2F2017%2F06%2F21%2Fhexo-github-blog%2F</url>
    <content type="text"><![CDATA[最近用使用Hexo和github搭建了一个个人博客，现在记录下来;Hexo是一个强大的博客框架,这里是中文文档 一、基础博客搭建流程安装Node和Git windows：下载Node.js客户端安装即可。在命令行输入node -v出现如下图所示就安装成功了 下载git(国内直接从官网下载比较困难，需要翻墙。这里提供一个国内的下载站)download 安装正确后 在桌面或文件夹空白处鼠标右键菜单会新增“Git GUI Here”和“Git Bash Here”两个选项。 使用hexo搭建博客 安装全局hexo右键运行Git Bash 执行npm install -g hexo;安装后输入hexo -v,出现版本信息表示安装成功。 在项目中安装hexo 新建文件夹为你的博客项目名，进入项目打开Git Bash npm install hexo --save在项目中安装hexo; hexo init初始化hexo npm install安装hexo所需依赖包 安装hexo插件 npm install hexo-server --save 本地服务所需插件 npm install hexo-deployer-git --save使用git进行部署所需插件 在本地生成博客静态页面并预览在项目路径下打开Git Bash 在本地生成静态页面 hexo generate,生成一个存放静态文件的文件夹public;该命令可以简写为:hexo g 启动本地服务器hexo server,启动服务;简写为hexo s;默认网址为：http://localhost:4000/默认端口为4000，如果端口被占用,执行hexo s -p 5000表示指定服务端口为5000。 如果以上步骤都不出意外的话，你就会看到一个Hexo博客初始化的页面。 二、GitHub+hexo配置个人博客 上面介绍了如何在本地搭建博客，接下来开始配置GitHub并关联Hexo GitHub pages 首先注册一个GigHub帐号，注册比较简单就不再赘 帐号创建号后，需要创建一个仓库(Respository);注意:仓库名字要与GitHub用户名一致,比如我的用户名是FireYao,创建的respository名就是FireYao.github.io 创建好respository后，进入到该respository界面,点击settings拉到最下方找到GitHub Pages,点击 Launch automatic page generator,让GitHub生成GitHubPager 配置SSH Keys 本地生成ssh密钥。git bash下输入ssh-keygen -t rsa -C ‘你的邮箱地址’ 上传本地的公钥串，使当前电脑与GitHub账户建立联系。 在你的电脑C：\ Users\你的计算机用户名.ssh目录下打开刚刚生成的id_rsa.pub，复制里面的内容。然后点击你GitHub账户右上角的头像，选择settings，找到SSH and GPG keys，点击进入之后再点击New SSH key，title随便写，把公钥串粘贴到文本框，保存即可 在Hexo配置文件中关联GitHub账号 在之前搭建好的本地博客项目中编辑_config.yml文件,把其中的deploy参数（没有的话就按如下格式新建，注意冒号后面一定要有一个空格），修改为：1234deploy: type: git repo: https://github.com/FireYao/FireYao.github.io.git branch: master 将其中的FireYao改为你自己的github用户名 重新部署项目在博客根目录打开Git Bash依次执行 123hexo clean #会清除缓存文件db.json及之前生成的静态文件夹public；hexo g #会重新生成静态文件夹public；hexo deploy #把本地生成的静态文件部署到FireYao.github.io这个仓库中的master分支上；简写形式为hexo d hexo g 和 hexo d可以合并在一起写：hexo g -d 在浏览器中访问博客在浏览器中输入FireYao.github.io,没毛病的话，你应该就能看到之前在本地搭建的那个博客页面了。 小结 到这里已经通过Hexo创建了一个最原始的博客，并将博客的静态文件存放到github仓库中，通过外网以github的默认域名访问这个博客。未完待续]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
